/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { Color, } from "./components/interfaces/Color.model";
import { Variants, } from "./components/interfaces/Variants.model";
import { Breakpoints, } from "./components/interfaces/Breakpoints.model";
import { SpinerVariant, } from "./components/interfaces/SpinerVariant.mode";
export namespace Components {
    interface WlAppbar {
        "color"?: Color;
    }
    interface WlButton {
        "circular": boolean;
        "color"?: Color;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled": boolean;
        "href": string | undefined;
        /**
          * Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types).
         */
        "rel": string | undefined;
        "size"?: "sm" | "lg" | "xl";
        /**
          * Specifies where to display the linked URL. Only applies when an `href` is provided. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target": string | undefined;
        /**
          * The type of the button.
         */
        "type": "submit" | "reset" | "button";
        "variant": Variants;
    }
    interface WlCard {
    }
    interface WlCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface WlContainer {
        "fluid": boolean;
        "maxWidth": Breakpoints;
        "size": Breakpoints;
    }
    interface WlGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed": boolean;
    }
    interface WlModal {
        "close": () => Promise<boolean>;
        "open": () => Promise<unknown>;
        "show": boolean;
    }
    interface WlRow {
        "align": "center" | "end" | "start" | "baseline";
    }
    interface WlSpinner {
        "color": Color;
        "variant": SpinerVariant;
    }
}
declare global {
    interface HTMLWlAppbarElement extends Components.WlAppbar, HTMLStencilElement {
    }
    var HTMLWlAppbarElement: {
        prototype: HTMLWlAppbarElement;
        new (): HTMLWlAppbarElement;
    };
    interface HTMLWlButtonElement extends Components.WlButton, HTMLStencilElement {
    }
    var HTMLWlButtonElement: {
        prototype: HTMLWlButtonElement;
        new (): HTMLWlButtonElement;
    };
    interface HTMLWlCardElement extends Components.WlCard, HTMLStencilElement {
    }
    var HTMLWlCardElement: {
        prototype: HTMLWlCardElement;
        new (): HTMLWlCardElement;
    };
    interface HTMLWlColElement extends Components.WlCol, HTMLStencilElement {
    }
    var HTMLWlColElement: {
        prototype: HTMLWlColElement;
        new (): HTMLWlColElement;
    };
    interface HTMLWlContainerElement extends Components.WlContainer, HTMLStencilElement {
    }
    var HTMLWlContainerElement: {
        prototype: HTMLWlContainerElement;
        new (): HTMLWlContainerElement;
    };
    interface HTMLWlGridElement extends Components.WlGrid, HTMLStencilElement {
    }
    var HTMLWlGridElement: {
        prototype: HTMLWlGridElement;
        new (): HTMLWlGridElement;
    };
    interface HTMLWlModalElement extends Components.WlModal, HTMLStencilElement {
    }
    var HTMLWlModalElement: {
        prototype: HTMLWlModalElement;
        new (): HTMLWlModalElement;
    };
    interface HTMLWlRowElement extends Components.WlRow, HTMLStencilElement {
    }
    var HTMLWlRowElement: {
        prototype: HTMLWlRowElement;
        new (): HTMLWlRowElement;
    };
    interface HTMLWlSpinnerElement extends Components.WlSpinner, HTMLStencilElement {
    }
    var HTMLWlSpinnerElement: {
        prototype: HTMLWlSpinnerElement;
        new (): HTMLWlSpinnerElement;
    };
    interface HTMLElementTagNameMap {
        "wl-appbar": HTMLWlAppbarElement;
        "wl-button": HTMLWlButtonElement;
        "wl-card": HTMLWlCardElement;
        "wl-col": HTMLWlColElement;
        "wl-container": HTMLWlContainerElement;
        "wl-grid": HTMLWlGridElement;
        "wl-modal": HTMLWlModalElement;
        "wl-row": HTMLWlRowElement;
        "wl-spinner": HTMLWlSpinnerElement;
    }
}
declare namespace LocalJSX {
    interface WlAppbar {
        "color"?: Color;
    }
    interface WlButton {
        "circular"?: boolean;
        "color"?: Color;
        /**
          * If `true`, the user cannot interact with the button.
         */
        "disabled"?: boolean;
        "href"?: string | undefined;
        /**
          * Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types).
         */
        "rel"?: string | undefined;
        "size"?: "sm" | "lg" | "xl";
        /**
          * Specifies where to display the linked URL. Only applies when an `href` is provided. Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`.
         */
        "target"?: string | undefined;
        /**
          * The type of the button.
         */
        "type"?: "submit" | "reset" | "button";
        "variant"?: Variants;
    }
    interface WlCard {
    }
    interface WlCol {
        /**
          * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
         */
        "offset"?: string;
        /**
          * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetLg"?: string;
        /**
          * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetMd"?: string;
        /**
          * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetSm"?: string;
        /**
          * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXl"?: string;
        /**
          * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "offsetXs"?: string;
        /**
          * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
         */
        "pull"?: string;
        /**
          * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullLg"?: string;
        /**
          * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullMd"?: string;
        /**
          * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullSm"?: string;
        /**
          * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXl"?: string;
        /**
          * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
         */
        "pullXs"?: string;
        /**
          * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
         */
        "push"?: string;
        /**
          * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushLg"?: string;
        /**
          * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushMd"?: string;
        /**
          * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushSm"?: string;
        /**
          * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXl"?: string;
        /**
          * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
         */
        "pushXs"?: string;
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
         */
        "sizeXs"?: string;
    }
    interface WlContainer {
        "fluid"?: boolean;
        "maxWidth"?: Breakpoints;
        "size"?: Breakpoints;
    }
    interface WlGrid {
        /**
          * If `true`, the grid will have a fixed width based on the screen size.
         */
        "fixed"?: boolean;
    }
    interface WlModal {
        "show"?: boolean;
    }
    interface WlRow {
        "align"?: "center" | "end" | "start" | "baseline";
    }
    interface WlSpinner {
        "color"?: Color;
        "variant"?: SpinerVariant;
    }
    interface IntrinsicElements {
        "wl-appbar": WlAppbar;
        "wl-button": WlButton;
        "wl-card": WlCard;
        "wl-col": WlCol;
        "wl-container": WlContainer;
        "wl-grid": WlGrid;
        "wl-modal": WlModal;
        "wl-row": WlRow;
        "wl-spinner": WlSpinner;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "wl-appbar": LocalJSX.WlAppbar & JSXBase.HTMLAttributes<HTMLWlAppbarElement>;
            "wl-button": LocalJSX.WlButton & JSXBase.HTMLAttributes<HTMLWlButtonElement>;
            "wl-card": LocalJSX.WlCard & JSXBase.HTMLAttributes<HTMLWlCardElement>;
            "wl-col": LocalJSX.WlCol & JSXBase.HTMLAttributes<HTMLWlColElement>;
            "wl-container": LocalJSX.WlContainer & JSXBase.HTMLAttributes<HTMLWlContainerElement>;
            "wl-grid": LocalJSX.WlGrid & JSXBase.HTMLAttributes<HTMLWlGridElement>;
            "wl-modal": LocalJSX.WlModal & JSXBase.HTMLAttributes<HTMLWlModalElement>;
            "wl-row": LocalJSX.WlRow & JSXBase.HTMLAttributes<HTMLWlRowElement>;
            "wl-spinner": LocalJSX.WlSpinner & JSXBase.HTMLAttributes<HTMLWlSpinnerElement>;
        }
    }
}
